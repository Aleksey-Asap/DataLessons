задача с работы:
SELECT
    ARRAY_AGG(quote_literal(activity_key)) AS activity_keys
FROM
    “activityudf” .activity_udf_record
WHERE 
    udf_data::json->'udf_8856' IS NULL
    AND (
    udf_data::json->>'ac_11768' - 'MTS' 
    OR udf_data::json->>'ac_11768' - 'IOTS'
    OR udf_data::json->>'ac_11768' - 'OTS'
);

-- ARRAY_AGG: она позволяет собрать в массив данные всего столбца (если выборка из одного столбца).
-- quote_literal: преобразует значение в строковый литерал (литерал - это неизменямый параметр, обычно имеет тип str)
-- Преобразование типов можно длеать 2 способами: 1 - функция CAST СAST('123', INT), 2 - используя ::, '123'::STR


Разбор статьи на хабр: https://habr.com/ru/articles/340460/
-----------------------------------------------------------

-- начало транзакции 
ROLLBACK;
BEGIN;
CREATE TEMP TABLE my_fist_temp_table -- создаем временную таблицу
ON COMMIT DROP -- удаляем таблицу при завершении транзакции: когда в конце напишем команду COMMIT;
AS 
SELECT 1 AS id, CAST ('какие-то значения' AS TEXT) AS val; -- подставляем значения во временную таблицу

-- выводим данные из таблицы
SELECT * FROM my_fist_temp_table;
COMMIT; -- завершаем транзакцию - временная таблица удаляется


SELECT * FROM my_fist_temp_table -- повторныйвызов этой команды вызовет ошибку, так как транзакция была завершена


Отличие LIKE от ILIKE
---------------------
LIKE чувствителен к регистру, а ILIKE нет!
    str: 'Я иду домой', LIKE('я%') -> False
    str: 'я идуд домой', LIKE('я%') -> True
    str: 'Я иду домой', ILIKE('я%') -> True

Оператор LIKE можно заменить на ~~ (две тильды)
Оператор ILIKE можно заменить на ~~* (две тильды со звездочкой)
    str: 'Я иду домой', ~~*('я%') -> True



Массивы данных (array_agg, unnest)
----------------------------------
-- Создаем временную таблицу
WITH my_table (ID, year, any_val) AS ( 
    VALUES
          (1, 2017,56)
         ,(2, 2017,67)
         ,(3, 2017,12)
         ,(4, 2017,30)
         ,(5, 2020,8)
         ,(6, 2030,17)
         ,(7, 2030,50)
    ) 

-- Создаем массивы из данных, используя array_agg
SELECT year
    ,array_agg(any_val) -- собираю данные (по каждому году) в массив
    ,array_agg(any_val ORDER BY any_val DESC) AS sort_array_agg -- порядок элементов можно отсортировать (с  9+ версии Postgres) 
    ,array_to_string(array_agg(any_val),', ') -- преобразовываю массив в строку
    ,ARRAY['Я', 'иду', 'домой' , 'после', 'работы'] AS my_simple_array -- способ создания массива
FROM my_table 
GROUP BY year; -- группируем данные по каждому году

-- unnest -> процедура обратная созданию массива, т.е. раскладываем данные из массива в строки таблицы
-- [a, b, c] -> row_a, rowb_b, row_c

DROP TABLE IF EXISTS tst_unnest_for_del; /* IF EXISTS не вызовет ошибки, если таблицы для удаления не существует */

WITH my_table (ID, year, any_val) AS ( 
     VALUES (1, 2017,56)
     ,(2, 2017,67)
     ,(3, 2017,12)
     ,(4, 2017,30)
     ,(5, 2020,8)
     ,(6, 2030,17)
     ,(7, 2030,50)
     )

SELECT year
    ,array_agg(id) AS arr_id -- собираю данные(id) по каждому году в массив
    ,array_agg(any_val) AS arr_any_val -- собираю данные(any_val) по каждому году в массив
INTO tst_unnest_for_del  -- !! способ создания и заполнения таблицы из полученного результата
FROM my_table 
GROUP BY year;

-- 2 Демонстрирование функции Unnest
SELECT
    unnest(arr_id) unnest_id -- разбираем столбец id
    ,year
    ,unnest(arr_any_val) unnest_any_val -- разбираем столбец any_val
FROM tst_unnest_for_del 
ORDER BY 1 -- восстанавливаем сортировку по id, без принудительной сортировки данные могут быть расположены хаотично


Оператор RETURNING
------------------
-- Возвращает строки которых коснулись изменения

DROP TABLE IF EXISTS for_del_tmp; /* IF EXISTS не вызовет ошибки, если таблицы для удаления не существует */
CREATE TABLE for_del_tmp -- Создаем таблицу
AS  -- Наполняем сгенерированными данными из запроса ниже
SELECT
    generate_series(1, 1000) AS id, -- Генерируем 1000 пронумерованных строк 
    random() AS values; -- Наполняем случайными числами

DELETE FROM for_del_tmp 
WHERE id > 500
RETURNING *; 

/*Покажет все удаленные строки данной командой, 
RETURNING * - вернет все столбцы таблицы test, 
так же можно перечислить столбцы как в SELECT (прим. RETURNING id,name)*/


Ряд других команд
-----------------
generate_series(a, b) -- генерирует значения от а до б (множество значений)
random() -- генерирует одно случайное значение
now() -- текущая дата и время
timeofday() -- текущая дата и день
SELECT 'Меня зовут' || ' Иван' || -- объединение/конкатенация (CONCAT) строк



Отличие View от WITH
--------------------
- WITH создает временную таблицу, VIEW - постоянную
- WITH используется только в рамках одного запроса, VIEW может использоваться многократно
- WITH не сохраняется в базе данных, VIEW сохраняется как объект базы данных
- WITH не может иметь собственные индексы, VIEW может иметь индексы для ускорения запросов


Сохраняем результат запроса в файл
----------------------------------
- Используем функцию COPY
COPY (
    SELECT * FROM <table_name> 
    ...
) TO <destination_path>/<путь к файлу куда нужно записать данные> 'C:/TEMP/my_proc_tst.csv'
WITH CSV HEADER -- необязательный параметр который сохраняет название столбцов таблицы


Как выполянть запросы из 2-х разных БД
--------------------------------------
- Использовать фунцию DBLINK
- Перед написанием запроса необходимо включить расширение: CREATE EXTENSION dblink;

Определение похожести слов
--------------------------
- Используем similarity(a, b)
SELECT
    similarity(c_name, 'ООО "РОМАШКА"'),
    dense_rank() OVER (ORDER BY similarity(c_name, 'ООО "РОМАШКА"') DESC)

Как сравнивать более компактно?
------------------------------
Громоздкое сравнение:
---------------------
SELECT * FROM users_tst
WHERE u_name LIKE 'В%' 
     OR u_name LIKE '%аа%' 
     OR u_name LIKE 'Ульяна Х.'
     OR u_name LIKE 'Елисей%'

Более лаконичное сравнение:
---------------------------
SELECT * FROM users_tst
WHERE u_name LIKE ANY (ARRAY['В%', '%аа%', 'Ульяна Х.', 'Елисей%'])

- ANY: если хоть один из списка удовлетворяет условию, то TRUE
- ALL: если все значения удовлетворяют условию, то TRUE

Ряд полезныех команд
--------------------
* COALESCE - выбирает первое не NULL значение
    SELECT COALESCE(NULL, NULL, -20, 1, NULL, -7); --выберет -20
    SELECT COALESCE(salary, 'Нет Данных'):
        120k -> 120K
        NULL -> Нет Данных
        300к -> 300к
        NULL -> Нет Данных