задача с работы:
SELECT
    ARRAY_AGG(quote_literal(activity_key)) AS activity_keys
FROM
    “activityudf” .activity_udf_record
WHERE 
    udf_data::json->'udf_8856' IS NULL
    AND (
    udf_data::json->>'ac_11768' - 'MTS' 
    OR udf_data::json->>'ac_11768' - 'IOTS'
    OR udf_data::json->>'ac_11768' - 'OTS'
);

-- ARRAY_AGG: она позволяет собрать в массив данные всего столбца (если выборка из одного столбца).
-- quote_literal: преобразует значение в строковый литерал (литерал - это неизменямый параметр, обычно имеет тип str)
-- Преобразование типов можно длеать 2 способами: 1 - функция CAST СAST('123', INT), 2 - используя ::, '123'::STR


-- Разбор статьи на хабр: https://habr.com/ru/articles/340460/

-- начало транзакции 
ROLLBACK;
BEGIN;
CREATE TEMP TABLE my_fist_temp_table -- создаем временную таблицу
ON COMMIT DROP -- удаляем таблицу при завершении транзакции: когда в конце напишем команду COMMIT;
AS 
SELECT 1 AS id, CAST ('какие-то значения' AS TEXT) AS val; -- подставляем значения во временную таблицу

-- выводим данные из таблицы
SELECT * FROM my_fist_temp_table;
COMMIT; -- завершаем транзакцию - временная таблица удаляется


SELECT * FROM my_fist_temp_table -- повторныйвызов этой команды вызовет ошибку, так как транзакция была завершена

-- Отличие LIKE от ILIKE
LIKE чувствителен к регистру, а ILIKE нет!
    str: 'Я иду домой', LIKE('я%') -> False
    str: 'я идуд домой', LIKE('я%') -> True
    str: 'Я иду домой', ILIKE('я%') -> True

Оператор LIKE можно заменить на ~~ (две тильды)
Оператор ILIKE можно заменить на ~~* (две тильды со звездочкой)
    str: 'Я иду домой', ~~*('я%') -> True

array_agg
-- Создаем временную таблицу
WITH my_table (ID, year, any_val) AS ( 
    VALUES
          (1, 2017,56)
         ,(2, 2017,67)
         ,(3, 2017,12)
         ,(4, 2017,30)
         ,(5, 2020,8)
         ,(6, 2030,17)
         ,(7, 2030,50)
    ) 
     
SELECT year
    ,array_agg(any_val) -- собираю данные (по каждому году) в массив
    ,array_agg(any_val ORDER BY any_val DESC) AS sort_array_agg -- порядок элементов можно отсортировать (с  9+ версии Postgres) 
    ,array_to_string(array_agg(any_val),', ') -- преобразовываю массив в строку
    ,ARRAY['Я', 'иду', 'домой' , 'после', 'работы'] AS my_simple_array -- способ создания массива
FROM my_table 
GROUP BY year; -- группируем данные по каждому году